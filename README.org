#+title: Ft_Printf

* Makefile
** Integrating libft into libftprintf
The archive =libftprintf.a= that we are building needs to incorporate =libft.a=.

#+begin_src makefile
NAME = libftprintf.a
LIBFT = path/to/libft
OBJ_FILES = file1.o file2.o # Add your object files here

# Build target
$(NAME): $(OBJ_FILES) $(LIBFT)/libft.a
	cp $(LIBFT)/libft.a $(NAME)
	ar rc $(NAME) $(OBJ_FILES)
#+end_src

Otherwise we can not use our archive without explicitly linking =libft.a=.

Imagine an end-user that wants to use our new ft_printf and therefore is linking libftprintf to their project.

#+begin_src c
/* new_project.c */
#include "libftprintf.h"

int main() {
	ft_printf("Hello world");
    return 0;
}
#+end_src

When they compile their project:

#+begin_src shell
cc new_project.c libftprintf.a
#+end_src

Suppose ft_printf uses ft_putstr_fd from libft. It might look like this:

#+begin_src c
#include "libft.h"

int ft_printf(const char* fmt_string, ...) {
	ft_putstr_fd(fmt_string, STDOUT_FILENO);
	return 0;
}
#+end_src

If we built =libftprintf.a= without incorporating =libft.a=, the compilation would fail because the linker would not be able to resolve ft_putstr_fd, as it would not be part of our archive.

An archive essentially is an aggregation of object files that a compiler can link to, and ft_putstr_fd would not be present without inclusion.
** bear
[[https://github.com/rizsotto/Bear][bear]] is a program that generates compile_commands.json file for you, so that clang-language server knows how compile the programs.

#+begin_src shell
bear -- <your-build-command>
#+end_src

By having a bear rule in your Makefile

#+begin_src makefile
bear: $(TEST_TARGET) $(OBJ_FILES)
#+end_src

you can generate the compile_commands.json as follows

#+begin_src shell
bear -- make bear
#+end_src
* va_*
* conversions
* flags
* Testing
We are dealing with two problems testing a function like ft_prinft.
** Capturing output
Since we need to verify that we're printing the right thing to stdout, we need to capture what is actually printed to stdout.

Gtest has a feature that allows us to do that. The syntax is as follows.
#+begin_src cpp
testing::internal::CaptureStdout();
ft_printf(fmt_string, args...);
std::string ftPrintfResult = testing::internal::GetCapturedStdout();
#+end_src

** variadic arguments
Variadic arguments, also known as variadic functions, are functions in C (and other languages) that can accept a variable number of arguments.

In C, variadic functions are defined using the ellipsis (...) syntax in the function parameter list.

Actually there is no big problem, it is just so that we are not able to do parametrized tests easily. But the layout that I found I think is compelling and easy enough.
#+begin_src c

template<typename... Args>
void compare_printf(const char* fmt_string, Args... args) {
	...
}

TEST(ft_printf_test, without_arguments) {
    compare_printf("Hello", "");
	...
}


TEST(ft_printf_test, string_conversions) {
    compare_printf("Hello %s", "World");
}
#+end_src
