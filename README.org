#+title: Ft_Printf

* Makefile
** Integrating libft into libftprintf
The archive =libftprintf.a= that we are building needs to incorporate =libft.a=.

#+begin_src makefile
NAME = libftprintf.a
LIBFT = path/to/libft
OBJ_FILES = file1.o file2.o # Add your object files here

# Build target
$(NAME): $(OBJ_FILES) $(LIBFT)/libft.a
	cp $(LIBFT)/libft.a $(NAME)
	ar rc $(NAME) $(OBJ_FILES)
#+end_src

Otherwise we can not use our archive without explicitly linking =libft.a=.

Imagine an end-user that wants to use our new ft_printf and therefore is linking libftprintf to their project.

#+begin_src c
/* new_project.c */
#include "libftprintf.h"

int main() {
	ft_printf("Hello world");
    return 0;
}
#+end_src

When they compile their project:

#+begin_src shell
cc new_project.c libftprintf.a
#+end_src

Suppose ft_printf uses ft_putstr_fd from libft. It might look like this:

#+begin_src c
#include "libft.h"

int ft_printf(const char* fmt_string, ...) {
	ft_putstr_fd(fmt_string, STDOUT_FILENO);
	return 0;
}
#+end_src

If we built =libftprintf.a= without incorporating =libft.a=, the compilation would fail because the linker would not be able to resolve ft_putstr_fd, as it would not be part of our archive.

An archive essentially is an aggregation of object files that a compiler can link to, and ft_putstr_fd would not be present without inclusion.
** bear
[[https://github.com/rizsotto/Bear][bear]] is a program that generates compile_commands.json file for you, so that clang-language server knows how compile the programs.

#+begin_src shell
bear -- <your-build-command>
#+end_src

By having a bear rule in your Makefile

#+begin_src makefile
bear: $(TEST_TARGET) $(OBJ_FILES)
#+end_src

you can generate the compile_commands.json as follows

#+begin_src shell
bear -- make bear
#+end_src

* va_*
The =va_arg=, =va_start=, and =va_end= macros are part of the C standard library and are used to handle functions with a variable number of arguments. They are defined in the =<stdarg.h>= header.

#+begin_src c
void va_start(va_list ap, last);
void va_end(va_list ap);
#+end_src

** va_start
#+begin_src c
void va_start(va_list ap, last);
#+end_src
- Initializes a =va_list= variable for subsequent use by =va_arg= and =va_end=.
- Should be called once before accessing the variable arguments.
- =ap= is the =va_list= variable, and =last= is the last fixed argument before the variable arguments.
** va_arg
#+begin_src c
type va_arg(va_list ap, type);
#+end_src
- Retrieves the next argument in the list.
- Should be called after =va_start= and before =va_end=.
- =ap= is the =va_list= variable, and =type= is the type of the next argument.
*** allowed types
**** a type so that by adding a * to the type it becomes a pointer to that type
Man page:
#+begin_example
The argument type is a type name specified so that the type of a pointer to an object that has the specified type can be obtained simply by adding a * to type.
#+end_example
- need to specify the type in a way that allows =va_arg= to correctly calculate the memory offset for the next argument
- this requirement needs special care when working with array and function types

***** arrays
Wrong:
#+begin_src c
int array[10] = va_arg(args, int[10]);
#+end_src
correct:
#+begin_src c
int *array = va_arg(args, int *);
#+end_src

***** functions
wrong:
#+begin_src c
void (func)() = va_arg(args, void());
#+end_src
correct (not tested yet):
#+begin_src c
void (*func)() = va_arg(args, void (*));
#+end_src

**** default argument promotion and fully promoted type
From the man page
#+begin_src c
/* need a cast here since va_arg only
   takes fully promoted types */
c = (char) va_arg(ap, int);
#+end_src

https://stackoverflow.com/a/1256122
https://stackoverflow.com/a/1255818

In C, function arguments undergo a process known as "default argument promotions" when passed to a variadic function like =printf=.

The default argument promotions ensure that arguments are compatible with the function's parameter types and include the following rules:
- Integral promotions:
  - Types smaller than =int= (like =char= and =short=) are promoted to =int= or =unsigned int= if =int= can represent all the values of the original type.
- Float arguments are promoted to =double= if the function parameter's type is =float=.

If the type specified in the function call does not match the actual promoted type of the argument, you may need to use appropriate casts to correctly interpret the value retrieved using =va_arg=.

#+begin_src c
/* need a cast here since va_arg only
   takes fully promoted types */
c = (char) va_arg(ap, int);
#+end_src

** va_end
#+begin_src c
void va_end(va_list ap);
#+end_src
- Cleans up the =va_list= variable when done.
- Should be called after accessing all the variable arguments.

* conversions
* flags
* Testing
